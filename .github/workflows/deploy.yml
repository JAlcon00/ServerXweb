name: Deploy Infrastructure

on:
  workflow_dispatch:
  push:
    branches: 
      - main
    paths:
      - '**.tf'
      - '**.sh'
      - '.github/workflows/**'

env:
  AWS_ACCESS_KEY_ID: ${{ secrets.SPACES_ACCESS_KEY }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.SPACES_SECRET_KEY }}
  TF_VAR_DIGITALOCEAN_TOKEN: ${{ secrets.DIGITALOCEAN_TOKEN }}
  TF_VAR_PRIVATE_KEY_PATH: "./keys/serverxweb"
  TF_VAR_SSH_KEY_ID: ${{ secrets.SSH_KEY_ID }}
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
  TF_LOG: DEBUG

jobs:
  terraform-apply:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.9.8
          terraform_wrapper: false

      - name: Configure SSH keys
        id: ssh-config
        run: |
          mkdir -p ./keys ~/.ssh
          
          # Validar secretos
          for secret in "SSH_PUBLIC_KEY" "SSH_PRIVATE_KEY"; do
            if [ -z "${{ secrets[secret] }}" ]; then
              echo "Error: $secret está vacío"
              exit 1
            fi
          done
          
          # Configurar claves SSH
          echo -n "${{ secrets.SSH_PUBLIC_KEY }}" > ./keys/serverxweb.pub
          echo -n "${{ secrets.SSH_PRIVATE_KEY }}" > ./keys/serverxweb
          chmod 600 ./keys/serverxweb
          chmod 644 ./keys/serverxweb.pub
          
          # Configurar SSH
          echo "Host *
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
          " > ~/.ssh/config
          
          # Validar clave pública
          if ! ssh-keygen -lf ./keys/serverxweb.pub; then
            echo "Error: Clave pública inválida"
            exit 1
          fi

      - name: Terraform Init & Plan
        id: tf-plan
        run: |
          terraform init
          terraform fmt -check
          terraform validate
          terraform plan -out=tfplan

      - name: Terraform Apply
        id: tf-apply
        run: terraform apply -auto-approve tfplan

      - name: Wait for Droplet Configuration
        id: wait-droplet
        run: |
          DROPLET_IP=$(terraform output -raw droplet_ip)
          echo "droplet_ip=${DROPLET_IP}" >> $GITHUB_OUTPUT
          
          echo "Esperando inicialización del Droplet..."
          for i in {1..12}; do
            if nc -z -w5 $DROPLET_IP 22; then
              echo "Puerto SSH disponible"
              sleep 15  # Esperar un poco más para que los servicios estén listos
              break
            fi
            echo "Intento $i: Puerto SSH no disponible, esperando..."
            sleep 15
          done

      - name: Install and Verify Dependencies
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ steps.wait-droplet.outputs.droplet_ip }}
          username: root
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            set -e
            if [ -f /root/node-install.sh ]; then
              chmod +x /root/node-install.sh
              /root/node-install.sh
            else
              echo "Error: node-install.sh no encontrado"
              exit 1
            fi
            
            # Verificar instalaciones
            command -v node >/dev/null 2>&1 || { echo "Node.js no instalado"; exit 1; }
            command -v npm >/dev/null 2>&1 || { echo "npm no instalado"; exit 1; }
            command -v pm2 >/dev/null 2>&1 || { echo "PM2 no instalado"; exit 1; }

      - name: Deploy and Verify Application
        if: success()
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ steps.wait-droplet.outputs.droplet_ip }}
          username: root
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            set -e
            cd /var/www/app
            pm2 reload backstore 2>/dev/null || pm2 start src/server.js --name backstore
            pm2 save
            
            # Verificar que la aplicación está corriendo
            if ! pm2 list | grep -q "online.*backstore"; then
              echo "Error: La aplicación no está en ejecución"
              pm2 logs backstore --lines 20
              exit 1
            fi
